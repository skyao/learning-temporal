---
title: "中文翻译版"
linkTitle: "中文翻译版"
weight: 10
date: 2023-12-28
description: >
  工作流版本策略中文翻译版
---

> 原文地址：https://community.temporal.io/t/workflow-versioning-strategies/6911

一旦你了解了编写[确定性工作流代码 180](https://docs.temporal.io/workflows#deterministic-constraints)的重要性，你可能会发现自己正在努力寻找修改这些代码的最佳方法。 在这里，我将概述一些常见的策略，以及何时以及如何使用它们。

基本上有三种方法可供您使用：worker版本控制、Patch/GetVersion API 和基于工作流名称的版本控制。 每种方法都有其相对的优缺点。 你应该优先使用前两种方法，因为它们是 Temporal 提供的官方支持方法（并且可以一起使用）。

让我们逐一看看：

## Worker 版本控制

请参阅 [Worker Versioning 316](https://docs.temporal.io/workers#worker-versioning) 上的官方文档。 除非您有更具体的需求，否则这应该是您的首选策略。

**优点：**

- 简单，内置
- 坚固耐用。 默认情况下，更改是相互隔离的，因此不太可能出错。
- 灵活 - 可以处理兼容和不兼容的更改

**缺点：**

- Worker 管理形式的一些运维负担。

## Patch 和 GetVersion API

我们[在 SDK 中为您提供了函数 317](https://docs.temporal.io/workflows#workflow-versioning)，让您可以根据工作流是否使用较新或较旧的代码运行，在工作流代码中进行分支。 它们的形式略有不同，具体取决于您使用的语言。 有关详细信息，请参阅链接的文档。

**优点：**

- 无需更改工作流启动器指向的位置
- 允许您更改当前打开的工作流的尚未执行的行为，同时保持与现有历史记录的兼容性。 新工作流的行为始终采用“新”路径。
- 可与 Worker 版本控制一起使用，以进行兼容的更改

**缺点：**

- 概念复杂
- 需要了解“旧”和“新”代码路径如何工作的认知负担
- 如果在同一工作流定义中无限期使用，可能会导致分支混乱

## 基于工作流名称的版本控制

与基于任务队列的版本控制非常相似，现在当您进行更改时，只需将工作流代码复制到 MyFooWorkflowV2 . 现在，您可以重新部署 **所有** worker，并将工作流启动器更改为指向工作流。

**优点：**

- 无需在不同队列中保持独立的 worker 队列
- 概念简单
- 必要时更容易修补旧版本，而不会影响新版本的代码

**缺点：**

- 代码重复--只有在知道该类型/版本的所有工作流都已完成时，才能删除旧的工作流代码
- 仍需要更新工作流启动器/客户端

## 基于任务队列的版本控制（由 Worker 版本控制取代）

> ![:warning:](https://emoji.discourse-cdn.com/twitter/warning.png?v=12) 别用这个！ 请改用如上所述的 Worker 版本控制！ 这部分内容仅供后人参考。

在这种方法中，在对工作流代码进行更改后，您将希望部署指向新任务队列的worker，而不是现有任务队列。 例如，如果您以前以任务队列为目标，则现在将以目标或类似目标为目标。 您还必须更新启动新工作流的任何源，以指向新的任务队列名称。 让旧的 worker 保持运行状态，可能会减少实例数，直到不再有打开的工作流。 然后，您可以停用所有这些。

**优点：**

- 概念简单
- 坚固耐用。 更改是相互隔离的，使错误不太可能发生。

**缺点：**

- 操作复杂（需要让旧 worker 保持活动状态并更改客户端指向的任务队列）。 这可能会导致出现许多旧 worker，尤其是在长时间运行的工作流中。
- 不能用于修复当前正在运行/打开的工作流中的错误
